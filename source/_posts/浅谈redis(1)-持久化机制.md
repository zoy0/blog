---
abbrlink: 
categories:
  - - note
cover: 
description: redis持久化
tags:
  - redis
title: 浅谈redis(1)-持久化机制
top_img: 'https://img.lazysun.me/202307301447764.jpg'
date: 2023-12-13 15:59:24
updated:aplayer:
aside:
comments:
highlight_shrink:
katex:
keywords:
mathjax:
type:
---

使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。



Redis支持三种持久化方式: RDB, AOF, RDB和AOF混合持久化

### RDB方式持久化

默认采用的持久化方式

Redis 可以通过创建快照来获得存储在内存里面的数据在 **某个时间点** 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，save会堵塞主进程，而bgsave则是fork出一个子进程执行快照备份。
redis.conf相关配置

```cobol
save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。

save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。
```

bgsava 过程中，Redis 依然**可以继续处理操作命令**的，也就是数据是能被修改的。关键的技术就在于**写时复制技术**(***Copy-On-Write, COW***)。

执行 bgsava 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个。

![img](https://img.lazysun.me/202310092117416.webp)

只有在发生修改内存数据的情况时，物理内存才会被复制一份。

![img](https://img.lazysun.me/202310092116866.webp)

当主线程和子线程都只是读共享数据时，内存没有任何变化，但是如果主线程发生了写操作，如主线程要**修改共享数据里的某一块数据**（比如键值对 A）时，就会发生写时复制，于是这块数据的**物理内存就会被复制一份（键值对** **A'）**，然后**主线程在这个数据副本（键值对A'）进行修改操作**。与此同时，**bgsave 子进程可以继续把原来的数据（键值对** **A）写入到 RDB 文件**。

写时复制可以保证bgsave生成的RDB文件是某个时间点的全量快照，但是再某种极端情况下，如**键值对被大量修改**，会复制出大量副本，占用许多内存空间。因此，在写操作比较频繁时，需要监控redis的内存变化

### AOF方式持久化

AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了），可以通过 `appendonly` 参数开启：

```cobol
appendonly yes
```

开启AOF后，每执行一条修改数据的命令后都会将该命令写入到AOF缓冲区`server.aof_buf`中，然后再写入AOF文件中，最后根据fsync策略决定何时进行刷盘。

#### AOF的基本流程

1. 命令追加(appen)：每一条修改数据的命令都会被添加到AOF缓冲区
2. 文件写入(write)：由AOF缓冲区写入AOF文件，使用`write`函数，此时数据被写入系统内核缓冲区，需要等待系统调度或者 `fsync` 方法强制刷新缓冲区，同步到磁盘
3. 文件同步(fsync)：AOF 缓冲区根据对应的持久化方式（ `fsync` 策略）向硬盘做同步操作。这一步需要调用 `fsync` 函数（系统调用）， `fsync` 针对单个文件操作，对其进行强制硬盘同步，`fsync` 将阻塞直到写入磁盘完成后返回，保证了数据持久化。
4. 文件重写(rewrite)：AOF文件过大时，会进行压缩。
5. 重写加载(load)：重启redis时，读取AOF文件的数据进行恢复

#### AOF持久化方式(fsync策略)

1. **appendfsync always**：每一次调用write方法后调用fsync同步到磁盘，会严重降低redis的性能。
2. **appendfsync everysec**：执行命令，调用 write 方法后立即返回，每隔1s调用fsync进行刷盘。
3. **appendfsync no**：执行命令，调用 write 方法后立即返回，让系统自行同步到磁盘。

#### AOF重写

当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。

![image-20231009205745562](https://img.lazysun.me/202310092114801.png)

#### AOF校检机制

AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 **校验和（checksum）** 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。

#### RDB-AOF混合方式

fork出来的子进程将内存副本全量已RDB的方式写入到AOP临时文件，再将重写缓冲区的增量以AOF的方式添加到临时文件末尾，最后将RDB + AOF混合的AOF文件取代旧的AOF文件。
